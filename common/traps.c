
/**********************************************************************
* © 2006 Microchip Technology Inc.
*
* FileName:        traps.c
* Dependencies:    p33FJ256GP710.h
* Processor:       dsPIC33F
* Compiler:        MPLAB® C30 v2.01 or higher
*
* SOFTWARE LICENSE AGREEMENT:
* Microchip Technology Inc. (“Microchip”) licenses this software to you
* solely for use with Microchip dsPIC® digital signal controller
* products. The software is owned by Microchip and is protected under
* applicable copyright laws.  All rights reserved.
*
* SOFTWARE IS PROVIDED “AS IS.”  MICROCHIP EXPRESSLY DISCLAIMS ANY
* WARRANTY OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING BUT NOT
* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
* PARTICULAR PURPOSE, OR NON-INFRINGEMENT. IN NO EVENT SHALL MICROCHIP
* BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR CONSEQUENTIAL
* DAMAGES, LOST PROFITS OR LOST DATA, HARM TO YOUR EQUIPMENT, COST OF
* PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS
* BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
* ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER SIMILAR COSTS.
*
* REVISION HISTORY:
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Author            Date      Comments on this revision
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
* Hrushikesh Vasuki 05/03/05  First release of source file
* Richard Fischer   07/14/05  Add DMAC exception handler
* Priyabrata Sinha  01/27/06  Ported to non-prototype devices
*
*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*
* ADDITIONAL NOTES:
* 1. This file contains trap service routines (handlers) for hardware
*    exceptions generated by the dsPIC30F device.
* 2. All trap service routines in this file simply ensure that device
*    continuously executes code within the trap service routine. Users
*    may modify the basic framework provided here to suit to the needs
*    of their application.
*
**********************************************************************/

#include "system.h"

void __attribute__((__interrupt__)) _OscillatorFail(void);
void __attribute__((__interrupt__)) _AddressError(void);
void __attribute__((__interrupt__)) _StackError(void);
void __attribute__((__interrupt__)) _MathError(void);
void __attribute__((__interrupt__)) _AltOscillatorFail(void);
void __attribute__((__interrupt__)) _AltAddressError(void);
void __attribute__((__interrupt__)) _AltStackError(void);
void __attribute__((__interrupt__)) _AltMathError(void);

/* Primary Exception Vector handlers:
   These routines are used if INTCON2bits.ALTIVT = 0.
   All trap service routines in this file simply ensure that device
   continuously executes code within the trap service routine. Users
   may modify the basic framework provided here to suit to the needs
   of their application. */

int16 INTCON1_Trap_Register __attribute__ ((persistent));

#ifdef MICRO_DSP
#define UART_NOT_READY (!U1STAbits.TRMT)
#define UART_TX_REG U1TXREG    
#else
#define UART_NOT_READY (!U2STAbits.TRMT)
#define UART_TX_REG U2TXREG    
#endif

#define PPUTCHAR(Ch) while(UART_NOT_READY); UART_TX_REG = Ch; asm("nop");
#define PPUT5(a,b,c,d,e)     PPUTCHAR(a);  PPUTCHAR(b);  PPUTCHAR(c);  PPUTCHAR(d);   PPUTCHAR(e);

void __attribute__((__interrupt__, no_auto_psv)) _OscillatorFail(void)
{
        register char a = 30;
        INTCON1_Trap_Register = INTCON1;
        while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5(' ','0','S','C','_');};
        INTCON1bits.OSCFAIL = 0;        //Clear the trap flag
       asm("reset");
        while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _AddressError(void)
{
        register char a = 30;
        INTCON1_Trap_Register = INTCON1;
        while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5(' ','A','D','D','R');};
        INTCON1bits.ADDRERR = 0;        //Clear the trap flag
        asm("reset");
        while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _StackError(void)
{
        register char a = 30;
       INTCON1_Trap_Register =  INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5('S','T','A','C','K');};
       INTCON1bits.STKERR = 0;         //Clear the trap flag
       asm("reset");
       while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _MathError(void)
{
        register char a = 30;
         INTCON1_Trap_Register = INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5(' ','M','A','T','H');};
       INTCON1bits.MATHERR = 0;        //Clear the trap flag
        asm("reset");
        while (1);
}



/* Alternate Exception Vector handlers:
   These routines are used if INTCON2bits.ALTIVT = 1.
   All trap service routines in this file simply ensure that device
   continuously executes code within the trap service routine. Users
   may modify the basic framework provided here to suit to the needs
   of their application. */

void __attribute__((__interrupt__, no_auto_psv)) _AltOscillatorFail(void)
{
        register char a = 30;
         INTCON1_Trap_Register = INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5('A','0','S','C',' ');};
       INTCON1bits.OSCFAIL = 0;
       asm("reset");
        while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _AltAddressError(void)
{
        register char a = 30;
         INTCON1_Trap_Register = INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5('A','A','D','D','R');};
      INTCON1bits.ADDRERR = 0;
       asm("reset");
        while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _AltStackError(void)
{
        register char a = 30;
         INTCON1_Trap_Register = INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5('A','S','T','C','K');};
      INTCON1bits.STKERR = 0;
      asm("reset");
        while (1);
}

void __attribute__((__interrupt__, no_auto_psv)) _AltMathError(void)
{
        register char a = 30;
         INTCON1_Trap_Register = INTCON1;
       while (a--) {     PPUT5('_',MICRO_ID_1,MICRO_ID_2,MICRO_ID_3,'_');  PPUT5('C','E','R','R','_'); PPUT5('A','M','A','T','H');};
       INTCON1bits.MATHERR = 0;
        asm("reset");
        while (1);
}


